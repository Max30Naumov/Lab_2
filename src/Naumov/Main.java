package Naumov;

import java.util.*;

public class Main {

    public static void main(String[] args) {

        // Правильной практикой является отделение проверочный данных от функций для их обработки

        // Создаем массив, передаем в функцию
        double[] task34arr = {-1, 2, 5, 0, -2};
        task34(task34arr);

        // Принцип работы аналогичен с массивом на 100 чисел
        int[] task59arr = {1, 1, 2, 3, 2, 6};
        task59(task59arr);

        int[] task84arr = {2, 2, 1, 0, 9999};
        // Поскольку мы получаем от функции массив, он должен быть преобразован в строку
        System.out.println(Arrays.toString(task84(task84arr)));

        double[] task109arr = {2, 3, 1, 0, 12};
        System.out.println(Arrays.toString(task109(task109arr, 2)));

        // Использование функции-обертки Integer вместо привычного int позволит отсортировать массив
        // Создаем массив Integer и заполняем его
        Integer[] task134arr = {2, 3, 1, 0, 12, 15, 15, 13, 13};
        // Передаем в функцию
        System.out.println(task134(task134arr));
    }

    /**
     * 34. Дан массив вещественных чисел, размер которого N. Подсчитать, сколько в нем
     * отрицательных, положительных и нулевых элементов.
     */
    private static void task34(double[] array) {
        // Инициализируем переменные-счетчики
        int negativeCounter = 0, positiveCounter = 0, zeroCounter = 0;
        // Проходимся по каждому элементу, увеличаем необходимый счетчик
        for (int i = 0; i < array.length; i++) {
            if (array[i] < 0) {
                negativeCounter++;
            } else if (array[i] > 0) {
                positiveCounter++;
            } else {
                zeroCounter++;
            }
        }
        // Выводим результат
        System.out.println("В массиве отрицательных элементов: " + negativeCounter +
                ", положительных: " + positiveCounter + ", нулевых: " + zeroCounter);
    }

    /**
     * 59. Дан массив, состоящий из 100 целых чисел. Вывести все числа, которые встречаются
     * в этом массиве:
     * а) несколько раз;
     * б) только по одному разу.
     */
    private static void task59(int[] array) {

        /* Создаем хеш-таблицу (гораздо проще, чем итерировать по массиву),
        в которую будем вносить ключ -- уникальные числа с массива, и значение --
        сколько раз число встречается
        */
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        // Проходимся по всем элементам
        for (int i = 0; i < array.length; i++) {
            // Создаем переменную-ключ под текущий элемент массива
            int key = array[i];
            // Если такой ключ уже есть в хеш-таблице, то
            if (map.containsKey(key)) {
                // Берем значение ключа
                int value = map.get(key);
                // И увеличиваем его на один
                map.put(key, value + 1);
            } else {
                // Если его нет, то добавляем со значением один
                // (только нашли такой ключ, потом будем увеличивать)
                map.put(key, 1);
            }
        }

        // Выводим сколько раз встречается каждый элемент
        System.out.println("Каждый элемент встречается:");

        // Проходимся по каждому элементу хеш-таблицы среди всех элементов
        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
            // Выводим ключ (число), и значение (сколько раз оно встретилось в массиве) на экран
            System.out.println(entry.getKey() + ":" + entry.getValue());
        }
    }

    /**
     * 84. Дана последовательность целых чисел, оканчивающаяся числом 9999. Количество
     * чисел в последовательности не меньше двух. Определить, есть ли в ней хотя бы одна
     * пара соседних четных чисел. В случае положительного ответа определить порядковые
     * номера чисел первой из таких пар.
     */
    private static int[] task84(int[] array) {
        // Проходимся по каждому элементу массива кроме последнего
        for (int i = 0; i < array.length - 1; i++) {
            // Если текущий и следущий элементы четные, то
            if (array[i] % 2 == 0 && array[i + 1] % 2 == 0) {
                // Запоминаем позиции четных элементов
                // Использование констант (final) хорошая практика, и предотвращает дальнейшие ошибки
                final int[] positions = {i, i + 1};
                // Возвращаем их, прерываем работу
                return positions;
            }
        }
        // Если прошлись по всем элементам, и не нашли четную пару, значит массив позиций пустой
        // Возвращаем его
        final int[] positions = {};
        return positions;

    }

    /**
     * 109. На k-e место одномерного массива вещественных чисел вставить число,
     * равное максимальному элементу массива.
     */
    private static double[] task109(double[] array, int k) {

        // Максимально маленькое значение Double — отрицательное максимальное
        // (Из-за особенностей Java)
        double maxNum = -Double.MAX_VALUE;
        // Создаем результирующий массив (на 1 больше чем оригинал)
        double[] result = new double[array.length + 1];

        // Проходимся по каждому элементу массива
        for (double num : array) {
            // Если текущий элемент больше, чем максимум, то обновляем максимум
            if (num > maxNum) {
                maxNum = num;
            }
        }
        // После этого завершения этого цикла в maxNum мы получаем максимальный элемент

        // Создаем индекс j для прохода по прошлому массиву
        int j = 0;
        // Используем индекс i для прохода по результирующему массиву
        for (int i = 0; i < array.length + 1; i++) {
            /* Если в результирующем массиве мы дошли до точки, где должны вставить maxNum, то
            вставляем его, и пропускаем увеличение j
            (вставляя новое значение мы должны пропустить одно с прошлого массива)
            */
            if (i == k) {
                result[i] = maxNum;
                // Если не дошли или перешли эту точку, то просто переносим значение со старого в новый
            } else {
                result[i] = array[j];
                j++;
            }
        }
        // Возвращаем результат
        return result;

    }

    /**
     * 134.	В массиве целых чисел с количеством элементов n найти наиболее часто встречающееся
     * число. Если таких чисел несколько, определить наименьшее из них.
     */
    private static int task134(Integer[] array) {
        // Чтобы решить эту задачу отсортируем массив в спадающем порядке
        // Таким образом мы решим проблему поиска найменьшего значения, ведь
        // самое последнее часто встречаемое и будет наименьшим

        // Для использования функции сортировки по убыванию нам нужен массив оберток (массив Integer)
        // Создаем копию для дальнейшей работы с ней и сохранения оригинала
        Integer sorted[] = array.clone();
        Arrays.sort(sorted, Collections.reverseOrder());
        // Переводим массив из Integer в int
        int[] arr = new int[sorted.length];
        // Проходимся по каждому элементу, и достаем из обертки Integer значение int
        for (int i = 0; i < sorted.length; i++) {
            arr[i] = sorted[i].intValue();
        }

        // Вводим три переменные:
        // 1. Счетчик -- сколько раз мы встретили одну цифру
        // 2. Максимальное значение счетчика -- обновляем его, когда счетчик превышает локальный рекорд
        // Ее значение должно быть настолько маленьким, чтобы при первой итерации оно обновилось
        // 3. Результат -- когда обновляем макс. значение счетчика -- запоминаем какая цифра это сделала
        int counter = 0, maxCounter = -1, result = 0;
        // Проходимся по каждому элементу со второго
        for (int i = 1; i < arr.length; i++) {
            // Сравниваем текущий с предыдущим, если они совпадают -- увеличиваем счетчик
            if (arr[i] == arr[i - 1]) {
                counter++;

                // Если счетчик бьет локальный максимум, то обновляем его
                if (counter >= maxCounter) {
                    maxCounter = counter;
                    // и запоминаем какая цифра сделала это
                    result = arr[i];
                }
                // А если пара чисел не совпала, то счетчик обнуляем
                // Чтобы следующая уникальная пара чисел начинала счет с начала
            } else {
                counter = 0;
            }
        }

        return result;
    }
}